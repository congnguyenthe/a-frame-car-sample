<html>
  <head>
    <title>A-Frame Test</title>
    <script src="dist/aframe-master.js"></script>
    <script src="dist/aframe-extras.min.js"></script>
    <script src="dist/aframe-physics-system.min.js"></script>
    <script src="dist/super-hands.min.js"></script>
    <script src="dist/aframe-physics-extras.min.js"></script>
    <script>
    AFRAME.registerComponent('car', {
      init: function () {
        window.addEventListener('keydown', this.onKeyDown.bind(this))
        window.addEventListener('keyup', this.onKeyUp.bind(this))
        this.rotating = null
        this.speeding = null
        this.speed = 0.0
        this.maxSpeed = 0.04;
        this.speedIncrement = this.maxSpeed / 10;  
      },
      onAxisMoveSpeed: function(e) {
        if (e.detail.axis[1] == 0) {
          this.speeding = null
        } else if (e.detail.axis[1] > 0) {
          this.speeding = 'down'
        } else if (e.detail.axis[1] < 0) {
          this.speeding = 'up'
        }
      },
      onAxisMoveAngle: function(e) {
        if (e.detail.axis[0] == 0) {
          this.rotating = null
        } else if (e.detail.axis[0] > 0) {
          this.rotating = 'right'
        } else if (e.detail.axis[0] < 0) {
          this.rotating = 'left'
        }
      },
      onKeyDown: function (e) {
        if (e.keyCode == 65) {
          this.rotating = 'left'
        } else if (e.keyCode == 68) {
          this.rotating = 'right'
        } else if (e.keyCode == 87) {
          this.speeding = 'up'
        } else if (e.keyCode == 83) {
          this.speeding = 'down'
        }
      },
      onKeyUp: function (e) {
        if (e.keyCode == 65 && this.rotating == 'left') {
          this.rotating = null
        } else if (e.keyCode == 68 && this.rotating == 'right') {
          this.rotating = null
        } else if (e.keyCode == 87 && this.speeding == 'up') {
          this.speeding = null
        } else if (e.keyCode == 83 && this.speeding == 'down') {
          this.speeding = null
        }
      },
      tick: function () {
        if (this.speeding != null) {
          const direction = this.speed > 0 ? 1 : -1
          if (this.rotating == 'left') {
            this.el.object3D.rotateY(direction * Math.PI / 120)
          } else if (this.rotating == 'right') {
            this.el.object3D.rotateY(direction * -Math.PI / 120)
          }
        }
        if (this.speeding == 'up') {
          this.speed = Math.min(this.speed + this.speedIncrement, this.maxSpeed)
        } else if (this.speeding == 'down') {
          this.speed = Math.max(this.speed - this.speedIncrement, -this.maxSpeed)
        }
        const position = this.el.getAttribute('position')
        const rotation = this.el.getAttribute('rotation')
        const angle = Math.PI * rotation.y / 180
        position.x += this.speed * Math.sin(angle)
        position.z += this.speed * Math.cos(angle)
        this.el.setAttribute('position', position)
        if (this.speed > 0) {
          this.speed = Math.max(this.speed - this.speedIncrement / 2, 0)
        }
        if (this.speed < 0) {
          this.speed = Math.min(this.speed + this.speedIncrement / 2, 0)
        }
      }
    })
    
    AFRAME.registerComponent('car-controller-left', {
      init: function () {
        this.el.addEventListener('axismove', function (e) {
          const car = document.querySelector('[car]').components.car
          car.onAxisMoveSpeed(e)
        })
      }
    })
    
    AFRAME.registerComponent('car-controller-right', {
      init: function () {
        this.el.addEventListener('axismove', function (e) {
          const car = document.querySelector('[car]').components.car
          car.onAxisMoveAngle(e)
        })
      }
    })

    AFRAME.registerComponent('screen-touch', {
      init: function () {
        this.viewerSpace = null;
        console.log('this.el', this.el);
        let plane = document.querySelector('a-plane');  
        this.el.sceneEl.renderer.vr.addEventListener('sessionend', (ev) => {
          console.log('sessionend', ev);
          this.viewerSpace = null;
          //plane.object3D.visible = true;
          plane.object3D.children[0].material = this.savedPlaneMaterial;
          this.savedPlaneMaterial = null;
        });
        this.el.sceneEl.renderer.vr.addEventListener('sessionstart', (ev) => {
          console.log('sessionstart', ev);
          //plane.object3D.visible = false;
          this.savedPlaneMaterial = plane.object3D.children[0].material;
          plane.object3D.children[0].material = new THREE.ShadowMaterial();
          plane.object3D.children[0].material.opacity = 0.3;

          let session = this.el.sceneEl.renderer.vr.getSession();
          session.requestReferenceSpace('viewer').then((space) => {
            console.log('got viewer space', space);
            this.viewerSpace = space;
          });
        });
      },
      tick: function () {
        if (!this.viewerSpace) return;

        let session = this.el.sceneEl.renderer.vr.getSession();
        if (!session) return;
        let inputs = session.inputSources;

        const car = document.querySelector('[car]').components.car
        car.rotating = null;
        car.speeding = null;
        if (!inputs.length)
          return;

        let source = inputs[0];
        //console.log('tick source=', source);
        let frame = this.el.sceneEl.frame;

        // Get a pose for the touch event in viewer space, this is locked to
        // the phone and moves with the phone. This way, the input pose
        // is relative to the virtual camera position. (For world interactions,
        // we'd want to use local-floor space or similar.)
        let inputPose = frame.getPose(source.targetRaySpace, this.viewerSpace);

        // Third column of the pose matrix is the Z axis basis vector in viewer
        // space coordinates. Use it to transform a (0, 0, -1, 1) vector, note
        // that its w component isn't necessarily equal to 1.
        //
        // Using three.js:
        //
        //let inputMat = new THREE.Matrix4();
        //inputMat.fromArray(inputPose.transform.matrix);
        //let vvec = new THREE.Vector4(0, 0, -1, 1);
        //vvec.applyMatrix4(inputMat);
        //
        // Equivalent unrolled version:
        let vx = -inputPose.transform.matrix[8];
        let vy = -inputPose.transform.matrix[9];
        let vz = -inputPose.transform.matrix[10];
        let vw = 1 - inputPose.transform.matrix[11];
        let vvec = new THREE.Vector4(vx, vy, vz, vw);

        // Move the cursor to the corresponding screen position. This is a
        // 3D point, but the Z location doesn't matter as long as its
        // projected location is where we want it to end up onscreen.
        let cursor = document.getElementById('cursor');
        //cursor.object3D.position.copy(vvec);
        cursor.setAttribute('position', vvec);

        // Now apply the screen projection to get a NDC vector
        // with x/y ranging from -1 to 1 covering the screen,
        // so the bottom left screen corner is (-1, -1).
        let viewerPose = frame.getViewerPose(this.viewerSpace);
        let proj = new THREE.Matrix4();
        proj.fromArray(viewerPose.views[0].projectionMatrix);
        let vproj = vvec.applyMatrix4(proj);
        vproj.divideScalar(vproj.w);

        //console.log('tick', vproj.x, vproj.y);

        if (vproj.x < -0.1) car.rotating = 'left';
        if (vproj.x > 0.1) car.rotating = 'right';
        if (vproj.y < -0.1) car.speeding = 'down';
        if (vproj.y > 0.1) car.speeding = 'up';
      }
    })
</script>
  </head>
  <body>
    <a-scene physics>
      <a-assets>
        <img id="ground" src="images/block.png">
        <img id="bg" src="images/bg.jpg">
        <a-asset-item id="car-obj" src="models/car.obj"></a-asset-item>
        <a-asset-item id="car-mtl" src="models/car.mtl"></a-asset-item>
        <a-mixin id="controller"
                 super-hands="colliderEvent: collisions;
                              colliderEventProperty: els;
                              colliderEndEvent: collisions;
                              colliderEndEventProperty: clearedEls;
                              grabStartButtons: gripdown, pointdown, triggerdown;
                              grabEndButtons: gripup, pointup, triggerup"
                 static-body="shape: sphere; sphereRadius: 0.11"
                 oculus-touch-controls="hand: left"
                 physics-collider
                 collision-filter = "collidesWith: default, red, green, blue;
                                     collisionForces: false">
      </a-assets>
      
      <a-entity>
        <a-camera position="0 1.2 0" wasd-controls-enabled="false"
        >
          <a-entity id="cursor" cursor="rayOrigin: mouse"
            position="0 0 -1"
            geometry="primitive: ring; radiusInner: 0.015; radiusOuter: 0.018"
            material="color: #888; shader: flat">
            <a-entity screen-touch></a-entity>
        </a-camera>
        <a-entity hand-controls="left" mixin="controller" car-controller-left></a-entity>
        <a-entity hand-controls="right" mixin="controller" car-controller-right></a-entity>
      </a-entity>

      <a-entity light="type: ambient; intensity: 0.5;"></a-entity>
      <a-light type="directional"
               light="castShadow: true;
                      shadowMapHeight: 1024;
                      shadowMapWidth: 1024;
                      shadowCameraLeft: -2;
                      shadowCameraRight: 2;
                      shadowCameraBottom: -2;
                      shadowCameraTop: 2;"
               id="light"
               target="#car"
               position="-5 3 1.5"></a-light>

      <a-box position="-1 0.25 -2"
             rotation="0 45 0"
             scale="0.5 0.5 0.5"
             color="#4CC3D9"
             shadow="cast:true; receive:true"
             ></a-box>

      <a-obj-model
        id="car"
        src="#car-obj"
        mtl="#car-mtl"
        position="0 0.01 -2"
        rotation="0 170 0"
        scale="0.25 0.25 0.25"
        shadow="cast:true; receive:true"
        car
        animation-mixer
        ></a-obj-model>

      <a-plane src="#ground" height="200" width="200" rotation="-90 0 0"
               repeat="200 200"
               shadow="receive:true"
               static-body></a-plane>
      <!-- 
           dynamic-body grabbable
           shadowCameraVisible: true;
           
           <a-sky src="#bg"></a-sky>
      -->
    </a-scene>
  </body>
</html>
