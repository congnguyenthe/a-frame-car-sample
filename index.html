<html>
  <head>
    <title>A-Frame Test</title>
    <script src="dist/aframe-master.js"></script>
    <script src="dist/aframe-extras.min.js"></script>
    <script src="dist/aframe-physics-system.min.js"></script>
    <!-- unused
      <script src="dist/super-hands.min.js"></script>
      <script src="dist/aframe-physics-extras.min.js"></script>
    -->
    <script>
    AFRAME.registerComponent('car', {
      init: function () {
        window.addEventListener('keydown', this.onKeyDown.bind(this))
        window.addEventListener('keyup', this.onKeyUp.bind(this))
        this.rotating = null
        this.speeding = null
        this.speed = 0.0
        this.maxSpeed = 0.04;
        this.speedIncrement = this.maxSpeed / 10;  
      },
      onAxisMoveSpeed: function(e) {
        if (e.detail.axis[1] == 0) {
          this.speeding = null
        } else if (e.detail.axis[1] > 0) {
          this.speeding = 'down'
        } else if (e.detail.axis[1] < 0) {
          this.speeding = 'up'
        }
      },
      onAxisMoveAngle: function(e) {
        if (e.detail.axis[0] == 0) {
          this.rotating = null
        } else if (e.detail.axis[0] > 0) {
          this.rotating = 'right'
        } else if (e.detail.axis[0] < 0) {
          this.rotating = 'left'
        }
      },
      onKeyDown: function (e) {
        if (e.keyCode == 65) {
          this.rotating = 'left'
        } else if (e.keyCode == 68) {
          this.rotating = 'right'
        } else if (e.keyCode == 87) {
          this.speeding = 'up'
        } else if (e.keyCode == 83) {
          this.speeding = 'down'
        }
      },
      onKeyUp: function (e) {
        if (e.keyCode == 65 && this.rotating == 'left') {
          this.rotating = null
        } else if (e.keyCode == 68 && this.rotating == 'right') {
          this.rotating = null
        } else if (e.keyCode == 87 && this.speeding == 'up') {
          this.speeding = null
        } else if (e.keyCode == 83 && this.speeding == 'down') {
          this.speeding = null
        }
      },
      tick: function () {
        if (this.speeding != null) {
          const direction = this.speed > 0 ? 1 : -1
          if (this.rotating == 'left') {
            this.el.object3D.rotateY(direction * Math.PI / 120)
          } else if (this.rotating == 'right') {
            this.el.object3D.rotateY(direction * -Math.PI / 120)
          }
        }
        if (this.speeding == 'up') {
          this.speed = Math.min(this.speed + this.speedIncrement, this.maxSpeed)
        } else if (this.speeding == 'down') {
          this.speed = Math.max(this.speed - this.speedIncrement, -this.maxSpeed)
        }
        const position = this.el.getAttribute('position')
        const rotation = this.el.getAttribute('rotation')
        const angle = Math.PI * rotation.y / 180
        position.x += this.speed * Math.sin(angle)
        position.z += this.speed * Math.cos(angle)
        this.el.setAttribute('position', position)
        if (this.speed > 0) {
          this.speed = Math.max(this.speed - this.speedIncrement / 2, 0)
        }
        if (this.speed < 0) {
          this.speed = Math.min(this.speed + this.speedIncrement / 2, 0)
        }
      }
    })
    
    AFRAME.registerComponent('car-controller-left', {
      init: function () {
        this.el.addEventListener('axismove', function (e) {
          const car = document.querySelector('[car]').components.car
          car.onAxisMoveSpeed(e)
        })
      }
    })
    
    AFRAME.registerComponent('car-controller-right', {
      init: function () {
        this.el.addEventListener('axismove', function (e) {
          const car = document.querySelector('[car]').components.car
          car.onAxisMoveAngle(e)
        })
      }
    })

    AFRAME.registerComponent('car-controller-two-axis', {
      init: function () {
        this.el.addEventListener('axismove', (ev) => {
          const car = document.querySelector('[car]').components.car;
          car.onAxisMoveAngle(ev);
          car.onAxisMoveSpeed(ev);
        });
      }
    })

    AFRAME.registerComponent('ar-set-invisible', {
      // Set this object's visibility to false while in AR mode.
      // TODO: could this be replaced with bind="visibility: !ar-mode"
      // with https://www.npmjs.com/package/aframe-state-component ?
      init: function () {
        this.el.sceneEl.addEventListener('enter-vr', (ev) => {
          if (this.el.sceneEl.is('ar-mode')) {
            this.el.setAttribute('visibility', false);
          }
        });
        this.el.sceneEl.addEventListener('exit-vr', (ev) => {
          this.el.setAttribute('visibility', true);
        });
      }
    })

    AFRAME.registerComponent('ar-shadows', {
      // Swap an object's material to a transparent shadows-only material while
      // in AR mode. Intended for use with a ground plane.
      schema: {
        opacity: {default: 0.3}
      },
      init: function () {
        this.el.sceneEl.addEventListener('enter-vr', (ev) => {
          console.log('session start', ev);
          if (this.el.sceneEl.is('ar-mode')) {
            console.log('AR session start', ev);
            this.savedMaterial = this.el.object3D.children[0].material;
            this.el.object3D.children[0].material = new THREE.ShadowMaterial();
            this.el.object3D.children[0].material.opacity = this.data.opacity;
          }
        });
        this.el.sceneEl.addEventListener('exit-vr', (ev) => {
          console.log('session end', ev);
          if (this.savedMaterial) {
            this.el.object3D.children[0].material = this.savedMaterial;
            this.savedMaterial = null;
          }
        });
      }
    })

    AFRAME.registerComponent('xr-two-axis-controller', {
      schema: {
        deadZone: {default: 0}
      },
      tick: function () {
        let emit = (x, y) => {
          let detail = {axis: [x, y, 0], changed: [0, 1]};
          this.deflected = (x != 0 || y != 0);
          this.el.emit('axismove', detail, false);
        };

        let session = this.el.sceneEl.renderer.vr.getSession();
        if (!session) return;
        let inputs = session.inputSources;

        for (let i = 0; i < inputs.length; ++i) {
          let source = inputs[i];
          //console.log('tick source=', source);
          // Ignore screen touch.
          if (source.targetRayMode == "screen")
            continue;
          if (!source.gamepad || source.gamepad.axes.length < 2)
            continue;

          have_input = true;
          let x = source.gamepad.axes[0];
          let y = source.gamepad.axes[1];
          // Apply a dead zone to the controller axes.
          if (Math.abs(x) < this.data.deadZone) x = 0;
          if (Math.abs(y) < this.data.deadZone) y = 0;
          //console.log('tick', vproj.x, vproj.y);
          emit(x, y);
        }
      }
    })

    AFRAME.registerComponent('screen-controller', {
      schema: {
        deadZone: {default: 0}
      },
      init: function () {
        this.viewerSpace = null;
        this.deflected = false;
        console.log('this.el', this.el);
        this.el.sceneEl.renderer.vr.addEventListener('sessionend', (ev) => {
          console.log('sessionend', ev);
          this.viewerSpace = null;
        });
        this.el.sceneEl.renderer.vr.addEventListener('sessionstart', (ev) => {
          console.log('sessionstart', ev);

          let session = this.el.sceneEl.renderer.vr.getSession();

          // Get a 'viewer' reference space (attached to the phone) for use
          // with screen space input.
          session.requestReferenceSpace('viewer').then((space) => {
            console.log('got viewer space', space);
            this.viewerSpace = space;
          });
        });
      },
      tick: function () {
        if (!this.viewerSpace) return;

        let emit = (x, y) => {
          let detail = {axis: [x, y, 0], changed: [0, 1]};
          this.deflected = (x != 0 || y != 0);
          this.el.emit('axismove', detail, false);
        };

        let session = this.el.sceneEl.renderer.vr.getSession();
        if (!session) return;
        let inputs = session.inputSources;

        let have_input = false;
        for (let i = 0; i < inputs.length; ++i) {
          let source = inputs[i];
          //console.log('tick source=', source);
          // Ignore inputs other than screen touch. Other controller types
          // are handled separately.
          if (source.targetRayMode != "screen")
            continue;

          let frame = this.el.sceneEl.frame;

          // Get a pose for the touch event in viewer space, this is locked to
          // the phone and moves with the phone. This way, the input pose
          // is relative to the virtual camera position. (For world interactions,
          // we'd want to use local-floor space or similar.)
          let inputPose = frame.getPose(source.targetRaySpace, this.viewerSpace);

          // Transform a point on the input space ray into viewer space. This is
          // the transform matrix multiplied by a (0, 0, -1, 1) vector,
          // equivalent to subtracting the Z axis basis vector (third column)
          // from the ray origin in viewer space (fourth column).
          //
          // Using three.js:
          //
          //let inputMat = new THREE.Matrix4();
          //inputMat.fromArray(inputPose.transform.matrix);
          //let vvec = new THREE.Vector4(0, 0, -1, 1);
          //vvec.applyMatrix4(inputMat);
          //
          // Equivalent unrolled version:
          let m = inputPose.transform.matrix;
          let vx = m[12] - m[8];
          let vy = m[13] - m[9];
          let vz = m[14] - m[10];
          let vw = 1 - m[11];
          let vvec = new THREE.Vector4(vx, vy, vz, vw);

          // For debugging, move the cursor to the corresponding screen
          // position. This is a 3D point, but the Z location doesn't matter as
          // long as its projected location is where we want it to end up
          // onscreen.
          //let cursor = document.getElementById('cursor');
          //cursor.setAttribute('position', vvec);

          // Now apply the screen projection to get a NDC vector
          // with x/y ranging from -1 to 1 covering the screen,
          // so the bottom left screen corner is (-1, -1).
          let viewerPose = frame.getViewerPose(this.viewerSpace);
          let proj = new THREE.Matrix4();
          proj.fromArray(viewerPose.views[0].projectionMatrix);
          let vproj = vvec.applyMatrix4(proj);
          vproj.divideScalar(vproj.w);

          have_input = true;
          // Apply a dead zone to the controller axes.
          if (Math.abs(vproj.x) < this.data.deadZone) vproj.x = 0;
          if (Math.abs(vproj.y) < this.data.deadZone) vproj.y = 0;
          //console.log('tick', vproj.x, vproj.y);
          emit(vproj.x, -vproj.y);
        }

        // If we haven't seen any screen input, make sure the virtual joystick
        // returns to center if needed.
        if (!have_input && this.deflected) {
          emit(0, 0);
        }
      }
    })

</script>
  </head>
  <body>
    <a-scene physics="debug: false">
      <a-assets>
        <img id="ground" src="images/block.png">
        <img id="bg" src="images/bg.jpg">
        <a-asset-item id="car-obj" src="models/car.obj"></a-asset-item>
        <a-asset-item id="car-mtl" src="models/car.mtl"></a-asset-item>
        <a-mixin id="controller"
                 tracked-controls
               <!--
                 super-hands="colliderEvent: collisions;
                              colliderEventProperty: els;
                              colliderEndEvent: collisions;
                              colliderEndEventProperty: clearedEls;
                              grabStartButtons: gripdown, pointdown, triggerdown;
                              grabEndButtons: gripup, pointup, triggerup"
                 static-body="shape: sphere; sphereRadius: 0.11"
                 oculus-touch-controls="hand: left"
                 physics-collider
                 collision-filter = "collidesWith: default, red, green, blue;
                                     collisionForces: false"
               -->
        >
      </a-assets>
      
      <a-entity>
        <a-camera position="0 1.2 0" wasd-controls-enabled="false"
        >
          <a-entity id="cursor" cursor="rayOrigin: mouse"
            position="0 0 -1"
            visible="false"
            geometry="primitive: ring; radiusInner: 0.015; radiusOuter: 0.018"
            material="color: #888; shader: flat">
            <a-entity screen-touch></a-entity>
        </a-camera>
        <a-entity hand-controls="left" mixin="controller" car-controller-left></a-entity>
        <a-entity hand-controls="right" mixin="controller" car-controller-right></a-entity>
        <a-entity screen-controller="deadZone: 0.1" car-controller-two-axis></a-entity>
        <a-entity xr-two-axis-controller="deadZone: 0.1" car-controller-two-axis></a-entity>
      </a-entity>

      <a-entity light="type: ambient; intensity: 0.5;"></a-entity>
      <a-light type="directional"
               light="castShadow: true;
                      shadowMapHeight: 1024;
                      shadowMapWidth: 1024;
                      shadowCameraLeft: -2;
                      shadowCameraRight: 2;
                      shadowCameraBottom: -2;
                      shadowCameraTop: 2;"
               id="light"
               target="#car"
               position="-5 3 1.5"></a-light>

      <a-box position="-1 1.25 -2"
             rotation="0 45 0"
             width="0.5" height="0.5" depth="0.5"
             color="#4CC3D9"
             shadow="cast:true; receive:true"
             dynamic-body="shape: none"
             shape__main="shape: box; halfExtents: 0.25 0.25 0.25;"
             grabbable
             ></a-box>

      <a-box position="0 1.25 -2.5"
             rotation="0 45 0"
             width="0.25" height="0.25" depth="0.25"
             color="#4CC3D9"
             shadow="cast:true; receive:true"
             dynamic-body
             grabbable
             ></a-box>

      <a-box position="1 1.25 -2.5"
             rotation="0 45 0"
             width="0.25" height="0.25" depth="0.25"
             color="#4CC3D9"
             shadow="cast:true; receive:true"
             dynamic-body
             grabbable
             ></a-box>

      <a-sphere position="0 1.25 -3"
                radius="0.125"
                color="#4CC3D9"
                shadow="cast:true; receive:true"
                dynamic-body="angularDamping: 0.4"
                grabbable
                ></a-sphere>

      <a-sphere position="1 1.25 -2.5"
                radius="0.25"
                color="#4CC3D9"
                shadow="cast:true; receive:true"
                dynamic-body="angularDamping: 0.4"
                grabbable
                ></a-sphere>

      <a-obj-model
        id="car"
        src="#car-obj"
        mtl="#car-mtl"
        position="0 0.01 -2"
        rotation="0 170 0"
        scale="0.25 0.25 0.25"
        shadow="cast:true; receive:true"
        static-body="shape: none"
        shape__main="shape: box; halfExtents: 0.6 0.5 1; offset: 0 0 -0.6"
        car
        animation-mixer
        ></a-obj-model>

      <a-plane src="#ground" height="200" width="200" rotation="-90 0 0"
               repeat="200 200"
               shadow="receive:true"
               ar-shadows="opacity: 0.3"
               static-body="shape: none"
               shape__main="shape: box; halfExtents: 100 100 0.125; offset: 0 0 -0.125"
      ></a-plane>
      <a-sky src="#bg" ar-set-invisible></a-sky>

      <!-- Debugging settings
           shadowCameraVisible: true;
      -->
    </a-scene>
  </body>
</html>
